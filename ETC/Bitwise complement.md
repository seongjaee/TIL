# 비트 보수, Bitwise complement

## 문제의 시작

- C# `List<T> BinarySearch`문서를 보다가

   *... a negative number that is the bitwise complement...* 라는 문장 발견...

- 비트 보수인 음수? 가 이해가 되지 않았음.

- 그냥 이진수 표현의 0과 1을 뒤집는게 비트 보수아닌가, 이게 왜 음수가 되지.

- 그래서 직접 ~2 를 출력해보니 -3이라는 충격적인 결과:dizzy_face:

  ```python
  print(~2)  # -3
  ```

- C# 도 마찬가지

  ```C#
  Console.WriteLine(~2);  // -3
  ```

<br/>

## 개념

### 컴퓨터의 음수 표현

#### 1. 부호 비트 사용

- 정수 값을 저장할 때 맨 앞 비트를 양수면 0, 음수면 1로 저장한다.

- 문제점: 연산 결과가 이상해짐, +0과 -0이 존재
  - `0000 1010` => 10 
  - `1000 1010` => -10
  - 10 + (-10) => `1001 0100` => -20

#### 2. 1의 보수 이용

- 1의 보수 : 모든 bit를 반전
- 문제점: 비트 반전을 많이 해야함
  - `0000 1010` => 10
  - `1111 0101` => -10
  - 10 + (-10) => `1111 1111` =>(1의 보수를 취함)=> `0000 0000` => 0

#### 3. 2의 보수 이용

- 2의 보수 : 1의 보수에 1을 더해줌. 또는 가장 오른쪽의 1을 찾아 해당 1보다 왼쪽의 모든 비트를 반전.

- `0000 1010` => 10

- `1111 0110` => -10

- 10 + (-10) => `1 0000 0000` => 맨 앞자리 무시 => `0000 0000` => 0

- 현재 대부분의 시스템이 2의 보수 이용

- 8비트에서 2의 보수

  `0000 0000` => 0

  `0000 0001` => 1

  ...

  `0111 1101` => 125

  `0111 1110` => 126

  `0111 1111` => 127

  `1000 0000` => -128

  `1000 0001` => -127

  `1000 0010` => -126

  ...

  `1111 1101` => -3

  `1111 1110` => -2

  `1111 1111` => -1



### signed int 타입

- 부호를 갖는 정수, 맨 앞에 MSB로 부호를 표현(1이면 음수, 0이면 양수)
- 하나의 비트를 사용하지 않게 되는 셈이므로 숫자 표현 범위에서 비트하나가 줄어듬

- 4바이트(=32비트)로 –2,147,483,648 ~ 2,147,483,647 범위
- (`2 ** 31` == `2,147,483,648`)

<br/>

## 납득

- int 형은 signed 타입이다. 그리고 음수는 2의 보수를 사용한다.

- `2`의 이진수 표현(8비트로만 표현하면)은 `0000 0010`이고,

   `~2`는 비트반전을 해보면 `1111 1101`이다.

- `-3`를 2의 보수를 이용해 이진수로 표현해보자.

  `3`  =>  `0000 0011`

  `-3` = `3`의 2의보수 => `1111 1101`

- 즉 `~2`  == `-3`
- 사실 `n + (~n) == -1`일 수 밖에 없다.