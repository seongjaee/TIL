# 모던 자바스크립트 딥 다이브 정리

## 데이터 타입

### 원시 타입(Primitive type) vs 객체 타입(object/reference type)

- 자바스크립트(ES6)에는 7개의 데이터 타입이 있다. 이 7개의 데이터 타입은 크게 원시 타입과 객체 타입으로 분류된다.

- 원시 타입에는

  - 숫자 타입
  - 문자열 타입
  - 불리언 타입
  - undefined 타입
  - null 타입
  - Symbol 타입

  이 있다.

- 원시 타입과 객체 타입은 세 가지의 큰 차이점이 있다.

  1. 원시 값은 **변경 불가능한(immutable) 값**이다. 반면, 객체(참조) 타입의 값은 **변경 가능한(mutable) 값**이다.
  2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값이 저장**된다. 반면 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**된다.
  3. 원시 값을 갖는 변수를 다른 변수에 할당하면 **원본이 복사**되어 전달된다. 이를 **값에 의한 전달(pass by value)**라 한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사**되어 전달된다. 이를 **참조에 의한 전달(pass by reference)**라 한다.

  - "값에 의한 전달"과 "참조에 의한 전달"은 사실 자바스크립트를 위한 용어가 아니다. "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다. 하지만, 그 값이 원시 값이냐 참조 값이냐의 차이가 있다. 자바스크립트에는 "참조에 의한 전달"이 존재하지 않고 "값에 의한 전달"만 존재한다. 자바스크립트에는 포인터가 존재하지 않기 때문에 다른 언어의 "참조에 의한 전달"과 의미가 정확히 일치하지는 않는다.



### 데이터 타입이 필요한 이유

3가지 이유를 들 수 있다.

1. 값을 저장할 때 확보해야할 메모리 공간의 크기를 결정하기 위해
2. 값을 참조할 때 읽어야할 메모리 공간의 크기를 결정하기 위해
3. 메모리에서 읽어온 2진수를 어떻게 해석할지 결정하기 위해



### 동적 타입

- 자바스크립트는 동적 타입 언어이다.
- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 동적으로 변할 수 있다.
- 동적 타입의 단점
  - 유연하지만 신뢰성이 떨어진다.
  - 복잡한 프로그램에서 변화하는 변수를 추적하기 어려울 수 있다.
  - 변수의 타입을 확신할 수 없다. 변수를 사용하기 전에 타입을 체크하는 건 매우 번거롭고, 코드의 양이 증가한다.



## 타입 변환과 단축 평가

### 단축 평가 & 옵셔널 체이닝 & null 병합 연산자

#### 단축평가

- 단축 평가는 **논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환**한다. 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

- 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 참조할 때

  ```javascript
  const elem = null;
  const value = elem.value;  // TypeError: Cannot read property 'value' of null
  ```

  ```javascript
  const elem = null;
  const value = elem && elem.value;  // null
  ```

- 변수나 함수의 매개변수에 기본값을 설정할 때

  ```javascript
  const foo = 'apple' || 'default string'  // "apple"
  const goo = undefined || 'default string'  // "default string"
  ```

  ```javascript
  function getStringLength(str) {
      str = str || '';
      return str.length()
  }
  
  getStringLength()  // 0
  getStringLength('apple')  // 5
  
  // ES6 매개변수 기본값 설정
  function getStringLength(str = '') {
      return str.length()
  }
  ```

#### 옵셔널 체이닝

- ES11(ECMAScript2020)에서 도입되었다. `?.` 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

  ```javascript
  const elem = null;
  const value = elem?.value;  // undefined
  ```

#### null 병합 연산자

- ES11(ECMAScript2020)에서 도입되었다. `??` 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

- 변수에 기본값을 설정할 때 유용하다.

  ```javascript
  const foo = null ?? 'default string';
  console.log(foo);  // "default string"
  ```

  

#### 단축 평가와 옵셔널 체이닝, null 병합 연산자의 차이점

- `&&`을 이용한 단축 평가는 좌항 피연산자가 false로 평가되는 **Falsy값**(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이면 좌항 피연산자를 그대로 반환한다. `0`이나 `''`이 기본값으로 사용될 수 있다면 문제가 발생할 수 있다.
- 반면 옵셔널 체이닝 `?.`은 좌항 피연산자가 오직 `null`, `undefined`일 때만 좌항 피연산자를 반환한다.



- `||`을 이용한 단축 평가는 좌항 피연산자가 false로 평가되는 **Falsy값**(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이면 우항 피연산자를 그대로 반환한다. `0`이나 `''`이 기본값으로 사용될 수 있다면 문제가 발생할 수 있다.
- 반면 null 병합 연산자 `??`는 좌항 피연산자가 Falsy값이라도  `null` 또는 `undefined`가 아니면 좌항 피연산자를 반환한다.

## 원시 값과 객체의 비교

```javascript
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
}

console.log(person1 === person2);  // false
console.log(person1.name === person2.name)  // true
```

- `===`는 변수에 저장되어 있는 값을 타입 변환하지 않고 비교한다.

- 객체를 할당한 변수는 참조 값을 가지고 있다. 즉, `===` 를 통해 객체를 할당한 변수를 비교하면 참조 값을 비교한다.
- 객체 리터럴은 평가될 때마다 객체를 생성한다. 따라서 `person1`과 `person2`이 가리키는 객체는 내용은 같지만, 다른 메모리에 저장된 별개의 객체이므로 참조 값이 서로 다르다.
- 하지만 프로퍼티 값을 참조하는 `person1.name`과 `person2.name`은 값으로 평가될 수 있는 표현식이다. 두 표현식 모두 원시 값 `'Lee'`로 평가된다.

## 함수

- 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.
- 함수를 사용하는 이유
  - 코드의 재사용성
  - 유지보수의 편의성
  - 코드의 신뢰성
  - 코드의 가독성
- 함수를 정의하는 방법으로 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수가 있다.

### 함수 리터럴

- 자바스크립트의 함수는 객체 타입의 값이다. 함수도 함수 리터럴로 생성할 수 있다.

  ```javascript
  var f = function add(x, y) {
      return x + y;
  };
  ```

  - 함수 이름은 생략할 수 있다. 이름이 있으면 기명 함수, 없으면 무명/익명 함수.
  - 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.

### 함수 선언문

- ```javascript
  function add(x, y) {
      return x + y;
  }
  ```

- 함수 선언문은 함수 리터럴과 형태가 동일하지만, 함수 선언문은 **함수 이름을 생략할 수 없다.**

- 함수 선언문은 **표현식이 아닌 문**이다.

- 함수 선언문과 기명 함수 리터럴은 형태가 동일한 중의적인 코드다. 자바스크립트에서 중의적인 코드는 코드의 문맥에 따라 해석이 달라진다.

  - 기명 함수 리터럴을 단독으로 사용(함수 리터럴을 피연산자로 사용하지 않는 경우)하면 함수 선언문으로 해석
  - 함수 리터럴이 값으로 평가되어야 하는 문맥(변수 할당, 피연산자로 사용)이면 함수 리터럴 표현식으로 해석

  ```javascript
  (function bar() { console.log('bar')}; );
  bar();  // ReferenceError: bar is not defined
  ```

  - 그룹 연산자`()` 내에 피연산자로 사용된 함수 리터럴 `bar`는 함수 리터럴 표현식으로 해석된다.

- 함수 선언문과 함수 리터럴 표현식은 함수 객체를 생성한다는 점은 동일하지만 호출에 차이가 있다.

  - 함수 선언문으로 생성된 함수 객체는 호출할 수 있으나 함수 리터럴 표현식으로 생성된 함수 객체는 호출할 수 없다.
  - 함수 리터럴의 함수 이름은 함수 몸체 내에서만 참조할 수 있기 때문이다. 즉, 함수 리터럴에는 함수를 가리키는 식별자가 존재하지 않는다.

- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

  ```javascript
  var add = function foo (x, y) {
      return x + y;
  };
  
  console.log(add(3, 4))  // 7
  console.log(foo(3, 4))  // ReferenceError: foo is not defined
  ```

### 함수 표현식

- 자바스크립의 함수는 일급 객체다. 

- 따라서 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이런 방식을 함수 표현식이라 한다.

  ```javascript
  var add = function (x, y) {
      return x + y;
  };
  
  console.log(add(3, 4))  // 7
  ```

- 함수 선언문은 "표현식이 아닌 문"이고, 함수 표현식은 "표현식인 문"이다. 여기서 차이가 발생한다.

### 함수 생성 시점과 호이스팅

```javascript
console.log(add);  // f add(x, y)
console.log(sub);  // undefined

console.log(add(3, 4))  // 7
console.log(sub(3, 4))  // TypeError: sub is not a function

function add(x, y) {
    return x + y;
}

var sub = function (x, y) {
    return x + y;
}
```

- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출 가능하다. 하지만 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다. 이는 함수 생성 시점이 다르기 때문.

- 모든 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
- 이처럼 **함수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅**이라고 한다.
- 함수 호이스팅과 변수 호이스팅에는 차이가 있다.
  - `var`로 선언한 변수는 `undefined`로 초기화, 함수 선언문으로 암묵적으로 생성된 식별자는 함수 객체로 초기화.
  - 따라서 `var`  변수 선언문 이전에 변수를 참조하면 `undefined`로 평가되지만, 함수 선언문 이전에 함수를 호출하면 함수 호이스팅에 의해 호출이 가능하다.
- 정리하면 변수 할당문의 값은 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실핸되는 시점에 평가되어 함수 객체가 된다. 따라서 **함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생**한다.

- 함수 호이스팅은 함수 호출 전에 반드시 함수를 선언해야 한다는 규칙을 무시한다. 더글라스 크락포드는 함수 선언문 대신 함수 표현식 사용할 것을 권장한다.

### Function 생성자 함수

```javascript
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5))  // 7
```

- 일반적이지도 바람직하지도 않음
- 클로저를 생성하지 않는 등, 다른 방법으로 생성한 함수와 다르게 동작

### 화살표 함수

- ES6에 도입. 화살표 함수는 항상 익명 함수로 정의

```javascript
const add = (x, y) => x + y;
cnosole.log(add(2, 5))  // 7
```

- 기존 함수를 완전 대체하기 위한 것이 아님.
- 표현 뿐만 아니라 내부 동작 또한 간략화.
- 화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩, prototpye 프로퍼티 없음, arguments 객체 생성 x.

### 함수 호출

- 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 `undefined`로 초기화된 이후 인수가 순서대로 할당된다.
- 매개변수의 스코프는 함수 내부다.
- 자바스크립트의 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다. 
  - 인수가 부족하면 인수가 할당되지 않은 매개변수의 값은 `undefined`다.
  - 인수가 매개변수보다 많으면 초과된 인수는 무시된다.
    - 버려지는 것은 아님
- 모든 인수는 암묵적으로 `arguments` 객체의 프로퍼티로 보관된다.
- ES6에 도입된 매개변수 기본값을 사용하면 인수 체크 및 초기화를 간소화 할 수 있다. 매개변수 기본값은 매개변수에 인수를 전달하지 않은 경우와 `undefined`를 전달한 경우에만 유효하다.
- 함수의 매개변수는 코드를 이해하는 데 방해되는 요소이므로 이상적인 매개변수 개수는 0개. 매개변수가 많다는 것은 함수가 여러 가지 일을 한다는 것. 많은 매개변수가 필요하다면 객체를 인수로 전달하는 것이 유리.
  - 객체를 인수로 사용하면 매개변수의 순서를 신경 쓰지 않아도 된다는 장점. 명시적으로 인수의 의미를 설명하는 프로퍼티 키 사용으로 가독성이 좋아지고 실수가 줄어든다.
  - 하지만 함수로 전달한 객체를 함수 내부에서 변경하면 부수 효과(side effect) 발생.

### 참조에 의한 전달과 외부 상태의 변경

- 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달. 함수 몸체에서 그 값을 재할당해도 원본은 훼손되지 않음. 즉, 부수 효과가 발생하지 않음
- 객체 타입 인수는 참조 값이 복사되어 매개변수에 전달. 함수 몸체에서 그 값을 변경하면 원본이 훼손. 즉, 부수 효과 발생
- 객체를 불변 객체로 만들어 사용하는 방법으로 해결 가능.
  - 객체의 상태 변경을 원천 봉쇄. 객체의 상태 변경이 필요하면 깊은 복사를 통해 새로운 객체 생성, 재할당으로 교체.
- 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 **순수 함수**. 
- **함수형 프로그래밍** : 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그래밍 안정성을 높이려는 프로그래밍 패러다임

### 즉시 실행 함수

```javascript
(function () {
    // ...
}());

(function () {
    // ...
})();
```

- `()` 그룹 연산자로 함수를 묶은 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위함.

### 콜백 함수

```javascript
function repeat(n, f) {
    for (let i = 0; i < n; i++) {
        f(i);
    }
}
```

- 콜백 함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 고차 함수: 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
- 고차 함수는 콜백 함수를 자신의 일부로 합성한다.
- 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
- 콜백함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.



### 스코프 체인

- 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다. 이를 스코프 체인이라 한다.
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 변수를 검색한다.
- 자바스크립트 엔진은 코드를 실행하기 앞서 렉시컬 환경을 생성한다. 변수 선언이 실행되면 변수 식별자가 렉시컬 환경에 키로 등록되고, 변수 할당이 일어나면 변수 식별자에 해당하는 값을 변경한다.
- 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 전역 렉시컬 환경을 코드가 로드되면 생성되고, 함수 렉시컬 환경은 함수가 호출되면 생성된다.

### 렉시컬 스코프

- `var` 는 오직 함수의 코드 블록만을 지역 스코프로 인정한다. 이런 특성을 함수 레벨 스코프라 한다. 
- `let`, `const`는 블록 레벨 스코프를 지원한다.
- 동적 스코프 : **함수를 어디서 호출**했는지에 따라 함수의 상위 스코프를 결정
- 렉시컬 스코프 또는 정적 스코프 : **함수를 어디서 정의**했는지에 따라 함수의 상위 스코프 결정
- 자바스크립트는 렉시컬 스코프를 따름.

## 전역 변수의 문제점

- 암묵적 결합(implicit coupling)
  - 모든 코드가 전역 변수를 참조하고 변경할 수 있는 것
  - 코드의 가독성이 나빠지고 의도치 않은 상태 변경 위험
- 긴 생명 주기
  - 전역 변수는 생명 주기가 길다
  - 메모리 리소스 오래 소비
  - 변경될 시간도 길고 기회도 많음
- 스코프 체인 상에서 종점에 존재
  - 스코프 체인 상에서 가장 마지막에 위치하므로, 변수 검색 시 가장 마지막에 검색됨
  - 전역 변수의 검색 속도가 가장 느림
- 네임스페이스 오염
  - 자바스크립트의 가장 큰 문제 중 하나는 파일이 분리되어있다해도 하나의 전역 스코프를 공유한다는 것
  - 다른 파일 내 동일한 이름의 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 문제

### 전역 변수 사용 억제 방법

- 즉시 실행 함수
  - 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨
- 네임스페이스 객체
  - 전역 네임 스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
  - 식별자 충돌을 방지할 수 있으나 네임스페이스 객체 자체가 전역 변수이므로 그다지 유요하지 않음
- 모듈 패턴
  - 클로저 기반 동작
  - 전역 변수 억제 및 캡슐화
- ES6 모듈
  - ES6 모듈은 파일 자체의 독자적인 모듈 스코프 제공
  - script 태그에 type="module" 어트리뷰트 추가하면 자바스크립트 파일은 모듈로 작동
  - 트랜스파일링이나 번들링이 필요해 Webpack 등 모듈 번들러 사용이 일반적

