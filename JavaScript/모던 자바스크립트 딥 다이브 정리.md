# 모던 자바스크립트 딥 다이브 정리

## 데이터 타입

### 원시 타입(Primitive type) vs 객체 타입(object/reference type)

- 자바스크립트(ES6)에는 7개의 데이터 타입이 있다. 이 7개의 데이터 타입은 크게 원시 타입과 객체 타입으로 분류된다.

- 원시 타입에는

  - 숫자 타입
  - 문자열 타입
  - 불리언 타입
  - undefined 타입
  - null 타입
  - Symbol 타입

  이 있다.

- 원시 타입과 객체 타입은 세 가지의 큰 차이점이 있다.

  1. 원시 값은 **변경 불가능한(immutable) 값**이다. 반면, 객체(참조) 타입의 값은 **변경 가능한(mutable) 값**이다.
  2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값이 저장**된다. 반면 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**된다.
  3. 원시 값을 갖는 변수를 다른 변수에 할당하면 **원본이 복사**되어 전달된다. 이를 **값에 의한 전달(pass by value)**라 한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사**되어 전달된다. 이를 **참조에 의한 전달(pass by reference)**라 한다.

  - "값에 의한 전달"과 "참조에 의한 전달"은 사실 자바스크립트를 위한 용어가 아니다. "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다. 하지만, 그 값이 원시 값이냐 참조 값이냐의 차이가 있다. 자바스크립트에는 "참조에 의한 전달"이 존재하지 않고 "값에 의한 전달"만 존재한다. 자바스크립트에는 포인터가 존재하지 않기 때문에 다른 언어의 "참조에 의한 전달"과 의미가 정확히 일치하지는 않는다.



### 데이터 타입이 필요한 이유

3가지 이유를 들 수 있다.

1. 값을 저장할 때 확보해야할 메모리 공간의 크기를 결정하기 위해
2. 값을 참조할 때 읽어야할 메모리 공간의 크기를 결정하기 위해
3. 메모리에서 읽어온 2진수를 어떻게 해석할지 결정하기 위해



### 동적 타입

- 자바스크립트는 동적 타입 언어이다.
- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 동적으로 변할 수 있다.
- 동적 타입의 단점
  - 유연하지만 신뢰성이 떨어진다.
  - 복잡한 프로그램에서 변화하는 변수를 추적하기 어려울 수 있다.
  - 변수의 타입을 확신할 수 없다. 변수를 사용하기 전에 타입을 체크하는 건 매우 번거롭고, 코드의 양이 증가한다.



## 타입 변환과 단축 평가

### 단축 평가 & 옵셔널 체이닝 & null 병합 연산자

#### 단축평가

- 단축 평가는 **논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환**한다. 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

- 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 참조할 때

  ```javascript
  const elem = null;
  const value = elem.value;  // TypeError: Cannot read property 'value' of null
  ```

  ```javascript
  const elem = null;
  const value = elem && elem.value;  // null
  ```

- 변수나 함수의 매개변수에 기본값을 설정할 때

  ```javascript
  const foo = 'apple' || 'default string'  // "apple"
  const goo = undefined || 'default string'  // "default string"
  ```

  ```javascript
  function getStringLength(str) {
      str = str || '';
      return str.length()
  }
  
  getStringLength()  // 0
  getStringLength('apple')  // 5
  
  // ES6 매개변수 기본값 설정
  function getStringLength(str = '') {
      return str.length()
  }
  ```

#### 옵셔널 체이닝

- ES11(ECMAScript2020)에서 도입되었다. `?.` 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

  ```javascript
  const elem = null;
  const value = elem?.value;  // undefined
  ```

#### null 병합 연산자

- ES11(ECMAScript2020)에서 도입되었다. `??` 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

- 변수에 기본값을 설정할 때 유용하다.

  ```javascript
  const foo = null ?? 'default string';
  console.log(foo);  // "default string"
  ```

  

#### 단축 평가와 옵셔널 체이닝, null 병합 연산자의 차이점

- `&&`을 이용한 단축 평가는 좌항 피연산자가 false로 평가되는 **Falsy값**(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이면 좌항 피연산자를 그대로 반환한다. `0`이나 `''`이 기본값으로 사용될 수 있다면 문제가 발생할 수 있다.
- 반면 옵셔널 체이닝 `?.`은 좌항 피연산자가 오직 `null`, `undefined`일 때만 좌항 피연산자를 반환한다.



- `||`을 이용한 단축 평가는 좌항 피연산자가 false로 평가되는 **Falsy값**(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이면 우항 피연산자를 그대로 반환한다. `0`이나 `''`이 기본값으로 사용될 수 있다면 문제가 발생할 수 있다.
- 반면 null 병합 연산자 `??`는 좌항 피연산자가 Falsy값이라도  `null` 또는 `undefined`가 아니면 좌항 피연산자를 반환한다.

## 원시 값과 객체의 비교

```javascript
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
}

console.log(person1 === person2);  // false
console.log(person1.name === person2.name)  // true
```

- `===`는 변수에 저장되어 있는 값을 타입 변환하지 않고 비교한다.

- 객체를 할당한 변수는 참조 값을 가지고 있다. 즉, `===` 를 통해 객체를 할당한 변수를 비교하면 참조 값을 비교한다.
- 객체 리터럴은 평가될 때마다 객체를 생성한다. 따라서 `person1`과 `person2`이 가리키는 객체는 내용은 같지만, 다른 메모리에 저장된 별개의 객체이므로 참조 값이 서로 다르다.
- 하지만 프로퍼티 값을 참조하는 `person1.name`과 `person2.name`은 값으로 평가될 수 있는 표현식이다. 두 표현식 모두 원시 값 `'Lee'`로 평가된다.

## 함수

- 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.
- 함수를 사용하는 이유
  - 코드의 재사용성
  - 유지보수의 편의성
  - 코드의 신뢰성
  - 코드의 가독성
- 함수를 정의하는 방법으로 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수가 있다.

### 함수 리터럴

- 자바스크립트의 함수는 객체 타입의 값이다. 함수도 함수 리터럴로 생성할 수 있다.

  ```javascript
  var f = function add(x, y) {
      return x + y;
  };
  ```

  - 함수 이름은 생략할 수 있다. 이름이 있으면 기명 함수, 없으면 무명/익명 함수.
  - 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.

### 함수 선언문

- ```javascript
  function add(x, y) {
      return x + y;
  }
  ```

- 함수 선언문은 함수 리터럴과 형태가 동일하지만, 함수 선언문은 **함수 이름을 생략할 수 없다.**

- 함수 선언문은 **표현식이 아닌 문**이다.

- 함수 선언문과 기명 함수 리터럴은 형태가 동일한 중의적인 코드다. 자바스크립트에서 중의적인 코드는 코드의 문맥에 따라 해석이 달라진다.

  - 기명 함수 리터럴을 단독으로 사용(함수 리터럴을 피연산자로 사용하지 않는 경우)하면 함수 선언문으로 해석
  - 함수 리터럴이 값으로 평가되어야 하는 문맥(변수 할당, 피연산자로 사용)이면 함수 리터럴 표현식으로 해석

  ```javascript
  (function bar() { console.log('bar')}; );
  bar();  // ReferenceError: bar is not defined
  ```

  - 그룹 연산자`()` 내에 피연산자로 사용된 함수 리터럴 `bar`는 함수 리터럴 표현식으로 해석된다.

- 함수 선언문과 함수 리터럴 표현식은 함수 객체를 생성한다는 점은 동일하지만 호출에 차이가 있다.

  - 함수 선언문으로 생성된 함수 객체는 호출할 수 있으나 함수 리터럴 표현식으로 생성된 함수 객체는 호출할 수 없다.
  - 함수 리터럴의 함수 이름은 함수 몸체 내에서만 참조할 수 있기 때문이다. 즉, 함수 리터럴에는 함수를 가리키는 식별자가 존재하지 않는다.

- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

  ```javascript
  var add = function foo (x, y) {
      return x + y;
  };
  
  console.log(add(3, 4))  // 7
  console.log(foo(3, 4))  // ReferenceError: foo is not defined
  ```

### 함수 표현식

- 자바스크립의 함수는 일급 객체다. 

- 따라서 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이런 방식을 함수 표현식이라 한다.

  ```javascript
  var add = function (x, y) {
      return x + y;
  };
  
  console.log(add(3, 4))  // 7
  ```

- 함수 선언문은 "표현식이 아닌 문"이고, 함수 표현식은 "표현식인 문"이다. 여기서 차이가 발생한다.

### 함수 생성 시점과 호이스팅

```javascript
console.log(add);  // f add(x, y)
console.log(sub);  // undefined

console.log(add(3, 4))  // 7
console.log(sub(3, 4))  // TypeError: sub is not a function

function add(x, y) {
    return x + y;
}

var sub = function (x, y) {
    return x + y;
}
```

- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출 가능하다. 하지만 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다. 이는 함수 생성 시점이 다르기 때문.

- 모든 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
- 이처럼 **함수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅**이라고 한다.
- 함수 호이스팅과 변수 호이스팅에는 차이가 있다.
  - `var`로 선언한 변수는 `undefined`로 초기화, 함수 선언문으로 암묵적으로 생성된 식별자는 함수 객체로 초기화.
  - 따라서 `var`  변수 선언문 이전에 변수를 참조하면 `undefined`로 평가되지만, 함수 선언문 이전에 함수를 호출하면 함수 호이스팅에 의해 호출이 가능하다.
- 정리하면 변수 할당문의 값은 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실핸되는 시점에 평가되어 함수 객체가 된다. 따라서 **함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생**한다.

- 함수 호이스팅은 함수 호출 전에 반드시 함수를 선언해야 한다는 규칙을 무시한다. 더글라스 크락포드는 함수 선언문 대신 함수 표현식 사용할 것을 권장한다.

### Function 생성자 함수

```javascript
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5))  // 7
```

- 일반적이지도 바람직하지도 않음
- 클로저를 생성하지 않는 등, 다른 방법으로 생성한 함수와 다르게 동작

### 화살표 함수

- ES6에 도입. 화살표 함수는 항상 익명 함수로 정의

```javascript
const add = (x, y) => x + y;
cnosole.log(add(2, 5))  // 7
```

- 기존 함수를 완전 대체하기 위한 것이 아님.
- 표현 뿐만 아니라 내부 동작 또한 간략화.
- 화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩, prototpye 프로퍼티 없음, arguments 객체 생성 x.

