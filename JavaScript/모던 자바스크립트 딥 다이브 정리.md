# 모던 자바스크립트 딥 다이브 정리

## 데이터 타입

### 원시 타입(Primitive type) vs 객체 타입(object/reference type)

- 자바스크립트(ES6)에는 7개의 데이터 타입이 있다. 이 7개의 데이터 타입은 크게 원시 타입과 객체 타입으로 분류된다.

- 원시 타입에는

  - 숫자 타입
  - 문자열 타입
  - 불리언 타입
  - undefined 타입
  - null 타입
  - Symbol 타입

  이 있다.

- 원시 타입과 객체 타입은 세 가지의 큰 차이점이 있다.

  1. 원시 값은 **변경 불가능한(immutable) 값**이다. 반면, 객체(참조) 타입의 값은 **변경 가능한(mutable) 값**이다.
  2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값이 저장**된다. 반면 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**된다.
  3. 원시 값을 갖는 변수를 다른 변수에 할당하면 **원본이 복사**되어 전달된다. 이를 **값에 의한 전달(pass by value)**라 한다. 반면 객체를 가리키는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사**되어 전달된다. 이를 **참조에 의한 전달(pass by reference)**라 한다.

  - "값에 의한 전달"과 "참조에 의한 전달"은 사실 자바스크립트를 위한 용어가 아니다. "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다. 하지만, 그 값이 원시 값이냐 참조 값이냐의 차이가 있다. 자바스크립트에는 "참조에 의한 전달"이 존재하지 않고 "값에 의한 전달"만 존재한다. 자바스크립트에는 포인터가 존재하지 않기 때문에 다른 언어의 "참조에 의한 전달"과 의미가 정확히 일치하지는 않는다.



### 데이터 타입이 필요한 이유

3가지 이유를 들 수 있다.

1. 값을 저장할 때 확보해야할 메모리 공간의 크기를 결정하기 위해
2. 값을 참조할 때 읽어야할 메모리 공간의 크기를 결정하기 위해
3. 메모리에서 읽어온 2진수를 어떻게 해석할지 결정하기 위해



### 동적 타입

- 자바스크립트는 동적 타입 언어이다.
- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 동적으로 변할 수 있다.
- 동적 타입의 단점
  - 유연하지만 신뢰성이 떨어진다.
  - 복잡한 프로그램에서 변화하는 변수를 추적하기 어려울 수 있다.
  - 변수의 타입을 확신할 수 없다. 변수를 사용하기 전에 타입을 체크하는 건 매우 번거롭고, 코드의 양이 증가한다.



## 타입 변환과 단축 평가

### 단축 평가 & 옵셔널 체이닝 & null 병합 연산자

#### 단축평가

- 단축 평가는 **논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환**한다. 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

- 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 참조할 때

  ```javascript
  const elem = null;
  const value = elem.value;  // TypeError: Cannot read property 'value' of null
  ```

  ```javascript
  const elem = null;
  const value = elem && elem.value;  // null
  ```

- 변수나 함수의 매개변수에 기본값을 설정할 때

  ```javascript
  const foo = 'apple' || 'default string'  // "apple"
  const goo = undefined || 'default string'  // "default string"
  ```

  ```javascript
  function getStringLength(str) {
      str = str || '';
      return str.length()
  }
  
  getStringLength()  // 0
  getStringLength('apple')  // 5
  
  // ES6 매개변수 기본값 설정
  function getStringLength(str = '') {
      return str.length()
  }
  ```

#### 옵셔널 체이닝

- ES11(ECMAScript2020)에서 도입되었다. `?.` 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

  ```javascript
  const elem = null;
  const value = elem?.value;  // undefined
  ```

#### null 병합 연산자

- ES11(ECMAScript2020)에서 도입되었다. `??` 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

- 변수에 기본값을 설정할 때 유용하다.

  ```javascript
  const foo = null ?? 'default string';
  console.log(foo);  // "default string"
  ```

  

#### 단축 평가와 옵셔널 체이닝, null 병합 연산자의 차이점

- `&&`을 이용한 단축 평가는 좌항 피연산자가 false로 평가되는 **Falsy값**(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이면 좌항 피연산자를 그대로 반환한다. `0`이나 `''`이 기본값으로 사용될 수 있다면 문제가 발생할 수 있다.
- 반면 옵셔널 체이닝 `?.`은 좌항 피연산자가 오직 `null`, `undefined`일 때만 좌항 피연산자를 반환한다.



- `||`을 이용한 단축 평가는 좌항 피연산자가 false로 평가되는 **Falsy값**(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이면 우항 피연산자를 그대로 반환한다. `0`이나 `''`이 기본값으로 사용될 수 있다면 문제가 발생할 수 있다.
- 반면 null 병합 연산자 `??`는 좌항 피연산자가 Falsy값이라도  `null` 또는 `undefined`가 아니면 좌항 피연산자를 반환한다.
