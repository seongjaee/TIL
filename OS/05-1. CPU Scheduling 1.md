# 운영체제 강의 정리

## 05-1. CPU Scheduling 1

### CPU and I/O Bursts in Program Execution

프로그램이 실행될 때, CPU burst와 I/O burst를 번갈아가며 실행.



### CPU-burst Time의 분포

CPU-burst 그래프

burst 시간이 짧은 CPU 작업의 빈도수는 큼 => IO bound job

burst 시간이 긴 CPU 작업의 빈도수는 적음 => CPU bound job



*여러 종류의 process가 섞여있기 때문에 CPU 스케줄링이 필요*

- Interactive job에게 적절한 response 제공 필요
- CPU와 IO 장치 등 시스템 자원을 골고루 효율적으로 사용해야함



### 프로세스의 특성 분류

**I/O bound process**

- CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job
- many short CPU bursts

**CPU bound process**

- 계산 위주의 job
- few very long CPU bursts



### CPU Scheduler & Dispatcher

**CPU Scheduler**

- Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스 고름

- OS 내부의 스케줄링을 위한 별도의 코드로 존재

**Dispatcher**

- CPU 제어권을 CPU 스케줄러에 의해 선택된 프로세스에게 넘김

- 이 과정을 context switch(문맥 교환)이라 함



CPU 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태 변화가 있는 경우

1. Running => Blocked (cf. IO 요청하는 시스템 콜)
2. Running => Ready (cf. 할당 시간 만료로 timer interrupt)
3. Blocked => Ready (cf. IO 완료 후 인터럽트)
4. Terminate

1, 4번의 스케줄링은 nonpreemptive (자진 반납)

나머지는 preemptive (강제로 뺏김)

