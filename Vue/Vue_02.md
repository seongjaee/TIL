# Vue_02

## SFC (Single File Component)

### component 컴포넌트

- 기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 캡슐화하는데 도움을 줌
- 다시 사용할 수 있는 범용성을 위해 개발된 소프트웨어 구성 요소를 의미
- 유지보수의 용이성, 재사용성 측면에서 강력한 기능 제공
- **Vue Component === Vue Instance**

### SFC

- Vue 컴포넌트 기반 개발의 핵심 특징
- 하나의 컴포넌트는 .vue 확장자 파일 하나 안에서 작성되는 코드의 결과물
- 화면의 특정 영역에 대한 HTML, CSS, JS 코드를 하나의 파일 .vue에서 관리
- 즉 .vue 확장자를 가진 싱글 파일 컴포넌트를 통해 개발하는 방식
- **Vue Component === Vue Instance == .vue 파일**

### Vue 컴포넌트

- 단일 파일에서의 개발
  - 처음엔 쉽게 개발 가능
  - 코드가 많아지면 변수 관리 힘들어짐, 유지보수에 많은 비용 발생
- 각 기능 별로 파일을 나눠서 개발
  - 처음 개발 준비 단계에서 시간 소요
  - 이후 변수 관리 용어, 기능별 유지보수 비용 감소
- 한 화면 안에서도 기능 별로 각기 다른 컴포넌트로 존재
  - 하나의 컴포넌트는 여러 개의 하위 컴포넌트를 가질 수 있음
- Vue 컴포넌트는 `const app = new Vue({...})`의 app을 의미
  - 컴포넌트 기반의 개발이 반드시 파일 단위로 구분되어야하는 건 아님
  - 단일 .html 파일 안에서도 여러 개의 컴포넌트를 만들어 개발 가능

## Vue CLI

- [공식 홈페이지](https://cli.vuejs.org/)

- Vue.js 개발을 위한 표준 도구
- 프로젝트의 구성을 도와주는 역할
- Vue 개발 생태계에서 표준 tool 기준을 목표로 함
- 확장 플러그인, GUI, ES2015 구성 요소 제공 등 다양한 tool 제공

### Node.js

- 2009 Ryan Dahl 발표

- 자바스크립트를 브라우저가 아닌 환경에서 구동할 수 있또록 하는 **자바스크립트 런타임 환경**
- 자바스크립트 언어의 태생적 한계 해결
- Chrome V8 엔진 제공, 여러 OS환경에서 실행할 수 있는 환경 제공
- 자바스크립트를 SSR 아키텍쳐에서도 사용가능하도록 함

### NPM (Node Package Manage)

- 자바스크립트 언어를 위한 패키지 관리자
- Node.js 기본 패키지 관리자



### Babel & Webpack

#### Babel

- JavaScript complier
- 자바스크립트 ES2015+ 코드를 이전 버전으로 컴파일하는 도구
- 과거 자바스크립트 코드의 스펙트럼이 매우 다양
- 원시 코드를 목적 코드로 옮기는 번역기가 등장함에 따라 내 코드가 특정 브라우저에서 동작하니 않는 상황에대해 크게 고민하지 않을 수 있게 됨.

#### Webpack

- static module bundler
- 모듈 간의 의존성 문제 해결하기 위한 도구
- 프로젝트에 필요한 모든 모듈을 매핑하고 내부적으로 종속성 그래프를 빌드
- 모듈 === 파일 하나
- 배경
  - 브라우저만 조작할 수 있던 자바스크립트는 모듈 관련 문법 없이 사용
  - 자바스크립트와 애플리케이션의 크기가 커짐에 따라 전역 scope 공유하는 형태의 기존 개발 방식의 한계
  - 라이브러리를 만들어 필요한 모듈을 불러오고 코드를 모듈 단위로 작성
  - 현재 모듈 시스템이 2015년 표준으로 등재, 대부분의 브라우저와 Node.js가 모듈 시스템 지원
  - 모듈의 수가 많아지고 라이브러리 혹은 모듈 간의 의존성이 깊어지면서 디버깅의 어려움 발생
  - 모듈간 의존성 문제를 해결하기 위해 Webpack 등장
  - 모듈 의존성 문제를 해결해주는 작업을 Bundling
  - Bundling된 결과물은 더 이상 순서에 영향을 받지않고 동작
- Vue CLI는 Babel 과 Webpack 초기 설정이 자동으로 되어 있음.

- App.vue 최상위 컴포넌트
- 

## Pass Props & Emit event

- Vue app은 자연스럽게 중첩된 컴포넌트 트리로 구성
- 컴포넌트간 부모-자식 관계로 구성되며 의사소통이 필요
- 부모는 자식에게 데이터 전달(Pass props),
- 자식은 자신에게 일어난 일을 부모에게 알림(Emit event)
  - 부모와 자식이 명확하게 정의된 인터페이스를 통해 격리된 상태 유지
- "props는 아래로, events는 위로"
- 부모는 props를 통해 자식에게 '데이터' 전달, 자식은 events를 통해 부모에게 '메시지' 전달

### 컴포넌트 구조

1. 템플릿
   - HTML의 body 부분
   - 각 컴포넌트를 작성
2. 스크립트
   - JavaScript 작성되는 속
   - 컴포넌트 정보, 데이터, 메서드 등 Vue 인스턴스 대부분 구성
3. 스타일
   - CSS 작성
   - 컴포넌트 스타일

### 컴포넌트 등록

1. 불러오기
2. 등록하기
3. 보여주기

### Props

- props 부모 컴포넌트의 정보를 전달하기 위한 사용자 지정 특성
- 즉, 데이터는 props 옵션을 사용해 자식 컴포넌트로 전달
- 주의
  - 모든 컴포넌트 인스턴스에는 자체 격리 범위 존재
  - 자식 컴포넌트 템플릿에서 상위 데이터를 직접 참조할 수 없음

#### Props 이름 컨벤션

- 선언 시 : camelCase
- 템플릿 안 : kebab-case



#### 컴포넌트의 'data'는 반드시 함수여야함!

- 컴포넌트는 재사용이 가능해야함.
- 기본적으로 각 인스턴스는 모두 같은 data객체를 공유함!
- 따라서 새로운 data 객체를 반환하기 위해 함수 스코프를 이용.

- 주의
  - Static 구문을 사용해 숫자로 전달할 수 없음.
  - 숫자를 전달하기 위해선 JavaScript 표현식으로 평가되도록 v-bind를 사용해야함

#### 단방향 데이터 흐름

- 모든 props는 단방향 바인딩 형성 (부모 ->  자식)
- 부모 속성이 변경되면 자식 속성에서 전달, 반대는 안됨
  - 자식 요소가 의도치 않게 부모 요소 상태를 변경하여 데이터 흐름을 이해하기 어렵게 만드는 일을 방지
- 부모 컴포넌트가 업데이트될 때마다 자식 요소의 모든 prop들이 최신값으로 업데이트

### Emit event

- Listening to Child Components Events
- $emit(eventName)
  - 현재 인스턴스에서 이벤트를 트리거
  - 추가 인자는 리스너 콜백 함수로 전달
- 부모 컴포넌트는 자식 컴포넌트가 사용하는 템플릿에서 v-on을 사용하여 이벤트 청취(v-on을 이용한 사용자 지정 이벤트)



#### event 이름 컨벤션

- 컴포넌트 및 props 와 달리, 이벤트는 자동 대소문자 변환 제공 x
- HTML 대소문자 구분을 위해 DOM 템플릿의 v-on 이벤트 리스너는 항상 자동으로 소문자 변환되기 때문에 v-on:myEvent 는 자동으로 v-on:myevent로 변환
- 이벤트 이름은 항상 kebeb-case 사용 권장

## Vue Router

- Vue.js 공식 라우터
- SPA 상에서 라우팅을 쉽게 개발할 수 있는 기능을 제공
- 라우터
  - 위치에 대한 최적의 경로를 지정, 이 경로를 따라 데이터를 다음 장치로 전향시키는 장치

### Vue Router로 인한 변화

- App.vue 코드
- router/index.js 생성
- views 디렉토리 생성

- index.js
  - 라우트 관련 정보 및 설정 작성
- router-link 태그
  - 사용자 네비게이션을 가능하게 하는 컴포넌트
  - 목표 경로를 to prop으로 지정
  - router-link는 클릭 이벤트를 차단, 브라우저가 페이지를 다시 로드하지 않도록함
  - a태그지만 GET 요청을 보내는 이벤트가 제거된 형태
- router-view
  - 라우트에 대해 일치하는 컴포넌트를 렌더링하는 컴포넌트
  - 실제 컴포넌트가 DOM에 부착되는 그 자리
  - router-link를 클릭하면 해당 경로와 연결되어있는 (index.js에 정의한) 컴포넌트가 위치하게됨.
- History mode
  - HTML History API를 사용하여 router를 구현한 것
  - 히스토리는 남기지만 실제 페이지 이동은 하지 않는 기능
  - 페이지를 로드하지 않고 URL을 탐색할 수 있음
  - SPA의 단점인 URL 변경되지 않음을 해결
- History API
  - 브라우저의 세션 기록에 접근할 수 있는 방법을 제공
  - history 객체는 사용자가 자신의 방문 기록 앞, 뒤로 가거나, 기록의 특정 지점으로 이동하는 등의 메서드와 속성을 가짐

### Named Routes

- 이름을 갖는 라우트
- 명명된 경로로 이동하려면 객체를 Vue-route 컴포넌트 요소의 prop에 전달

### 프로그래밍 방식 네비게이션

- router의 인스턴스 메서드를 사용하여 프로그래밍 방식으로 같은 작업 수행

### Dynamic Route Matching

- 동적 인자 전달
- 주어진 패턴을 가진 라우트를 동일한 컴포넌트에 매핑해야하는 경우
- 동적 인자는 :로 시작
- 컴포넌트에서 `this.$route.params` 로 사용가능

### components 와 views

- views/
  - router(index.js)에 매핑된 컴포넌트들은 views에 작성하는 폴더
- components/
  - router에 매핑된 컴포넌트 내부에 작성하는 컴포넌트를 모아두는 폴더

### Vue Router의 필요성

- SPA
  - 서버는 index.html 하나만 제공
  - 이후의 모든 처리는 HTML위에 JS코드를 활용
  - 요청에 대한 처리를 서버가 하지 않음
- 라우팅 처리 차이
  - CSR에서 클라이언트는 응답받은 HTML문서 안에서 주소가 변경되면 특정 주소에 맞는 컴포넌트를 렌더링. 라우팅에 대한 결정권이 클라이언트한테 있음.
  - 라우팅의 결정권을 가진 Vue.js에서 라우팅을 편리하게 할 수 있는 Tool이 필요



