# 카운팅 정렬(Counting sort)

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘



<br/>

## 제한 사항

- 정수나 정수로 표현 가능한 자료만 적용 가능.
  - 각 항목 발생 횟수를 기록하기 위함
- 카운트를 위한 공간을 할당하기 위해 집합 내의 가장 큰 정수를 알아야함

<br/>

## 시간 복잡도

- O(n+k) : n=리스트 길이, k=정수의 최댓값

<br/>

## 예시 과정

- `arr = [0, 4, 1, 3, 5, 1, 5, 2, 4, 1]` 정렬

- 1단계, 카운트

  - arr를 순회하며 카운트 배열에 카운트 저장
  - `cnts = [1, 3, 1, 1, 2, 2],  # cnts[i] : i의 개수`

- 2단계, 누적 합 계산

  - 앞에서부터 누적합을 구한다.
  - `cnts = [1, 4, 5, 6, 8, 10]`

- 3단계

  - arr의 뒤에서부터 순회하며,

  - `arr[-1] = 1`이므로 `cnts[1]`의 값을 감소시키고

    `temp`의`cnts[1]` 인덱스에 1 을 저장하고

    `cnts = [1, 3, 5, 6, 8, 10]`

    `temp = [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]`

  - `arr[-2] = 4` 이므로  `cnts[4]`의 값을 감소시키고

    `temp`의`cnts[4]` 인덱스에 4을 저장하고

    `cnts = [1, 3, 5, 6, 7, 10]`

    `temp = [0, 0, 0, 1, 0, 0, 0, 0,]`

  - 즉, `arr`를 뒤에서부터 순회하면서

    `arr[k]`의 값에 대해, `cnts[arr[k]]`의 값을 감소시키고

     `temp[cnts[arr[k]]]` 에 `arr[k]`을 저장

<br/>

## 코드

```python
def counting_sort(A, B, k):
    # A : 입력 배열
    # B : 정렬 배열
    # C : 카운트 배열
    C = [0] * (k+1)
    
    # 개수 카운트
    for i in range(0, len(B)):
        C[A[i]] += 1
        
    # 앞에서부터 누적
    for i in range(1, len(C)):
        C[i] += C[i-1]
    
    # B의 뒤에서부터 순회하며 정렬
    for i in raneg(len(B)-1, -1, -1):
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]
        
```

<br/>

## 정리

- 평균 수행 시간 : O(n+k)

- 최악 수행 시간 : O(n+k)

- 비교환 방식

- n이 비교적 작을 때만 가능

