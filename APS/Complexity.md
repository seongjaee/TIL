# 복잡도

## 알고리즘의 효율

- 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
- 알고리즘의 효율
  - 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 요하는가
  - 시간적 효율성 : 연산량 대비 얼마나 적은 시간을 요하는가
  - 효율성의 반대 : 복잡도, 복잡도가 크면 효율성이 낮다.
- 알고리즘 효율성의 필요성
  - 일반적인 PC에서 10억 개의 숫자를 정렬하는 O(n^2) 알고리즘은 300년이 걸림. 반면 O(nlogn) 알고리즘은 5분.
  - 즉, 값비싼 하드웨어 기술 개발보다 효율적인 알고리즘이 경제적이다.

## 복잡도 분석

- 시간적 복잡도 분석
  - 하드웨어 환경에 따라 처리시간이 달라짐
    - 부동소수 처리 프로세서, 나눗셈 가속기능, 입출력 장비 성능 등 차이
  - 소프트웨어 환경에 따라 달라짐
    - 프로그램 언어 종류, 운영 체제 등 차이
  - 따라서 점근적 접근이 필요.
- 복잡도의 점근적 표기
  - 입력 크기에 대한 함수로 표기, 주로 다항식
  - 이를 단순한 함수로 표기하기 위해 점근적 표기 사용
  - n이 무한히 커질 때의 복잡도를 간단히 표기
    - Big-O, Big-Omega, Big-Theta 표기 등
- Big-O 표기
  - 복잡도의 점근적 상한, (어떤 n0 보다 큰 모든 n에 대해 상한이다.)
  - ex) f(n) = 2n^2 + 4n +7 => O(n^2)
  - 가장 높은 차수만 남김.
  - 최악의 경우 이정도 시간이 걸린다.
- Big-Omega 표기
  - 복잡도의 점근적 하한, (어떤 n0 보다 큰 모든 n에 대해 하한이다.)
  - ex) f(n) = 2n^2 + 4n +7 => Omega(n^2)
  - 가장 높은 차수만 남김
  - 최소한 이만한 시간은 걸린다.
- Big-Theta 표기
  - Big-O와 Big-Omega가 같은 경우에 사용
  - ex) f(n) = 2n^2 + 4n +7 => Theta(n^2)
  - 최악과 최선의 경우가 동일한 증가율을 가진다.
- 자주 나오는 O 표기
  - O(1) : 상수 시간
  - O(logn): 로그 시간
  - O(n) : 선형 시간
  - O(nlogn) : 로그 선형 시간
  - O(n^2) : 제곱 시간
  - O(n^3) : 세제곱 시간
  - O(2^n) : 지수 시간