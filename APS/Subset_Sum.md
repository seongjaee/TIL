# 부분집합 합 (Subset Sum)

- 유한 개의 정수로 이루어진 집합이 있다. 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제



## 완전 검색을 이용한 풀이

- 집합의 모든 부분 집합을 생성 후 각 부분집합의 합을 구한다.

- 부분 집합의 개수는 2^n개

### 비트 연산자

- `&` : 비트 단위로 AND 연산
- `|` : 비트 단위 OR 연산
- `^` : 비트 단위 XOR 연산
- `~` : 비트 단위 NOT 연산
- `<<` : 비트 열을 왼쪽으로 이동, 2^k을 곱해주는거나 마찬가지
  - `1 << n`  : 2^n
  - `3 << 2 == 12` : 3 * (2**2)
- `>>` : 비트 열을 오른쪽으로 이동, 2^k으로 나눈 몫
  - `5 >> 1 == 2`



### 비트 연산자를 활용한 부분 집합 생성

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(1<<n):  # 부분집합 개수만큼 순회, 2**n이랑 똑같음
    for j in range(n):  # j번째 비트 검사
        if i & (1 << j):  # 숫자 i의 j번째 비트가 1이면 j번째 원소 출력
            print(arr[j], end=", ")
    print()
print()
```

- `1 << n` : `i`는 0부터 2^n 까지 순회한다. 
  - 즉,`i`의 이진수 표현 중 1인 곳의 인덱스에 해당하는 원소만 포함하겠다!
  - ex) `i` = 13 -> `i`의 이진수 표현 `001011` -> 0, 1, 3번째 인덱스 포함 -> 부분집합 `[3, 6, 1]` 
- `1 << j` 는 j번째 비트만 1인 값이다.

- `i & (1 << j)`
  - 숫자 `i`의 비트 표현의 `j`번째 비트가 만약 1이면, 비트 AND 연산의 결과는 1이다. 즉, `True`
  - 숫자 `i`의 비트 표현의 `j`번째 비트가 만약 0이면, 비트 AND 연산의 결과는 0이다. 즉, `False`

### 풀이

```python
def subset_sum_zero(arr)
	n = len(arr)
    # 부분집합의 합이 0이 되는 경우의 수 저장
    total = 0  
    # 부분집합 개수만큼 순회, 2**n이랑 똑같음
    for i in range(1, 1 << n):
        subset_sum = 0
        for j in range(n):
            if i & (1 << j):
                subset_sum += arr[j]
                
        if subset_sum == 0:
            total += 1

    return total
```



