# 탐욕 알고리즘

## 탐욕 알고리즘

- 탐욕 알고리즘은 최적해를 구하는데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행해 최종해에 도달하는 방법
- 지역적으로는 최적이지만, 최종해가 **최적이라는 보장**은 없다.

- 일단 한번 선택된 것은 번복하지 않음. -> 단순하고 제한적인 문제들에 적용
- 최적화 문제 : 가능한 해들 중 가장 좋은 해를 찾는 문제.

### 탐욕 알고리즘 동작 과정

1. 해 선택 : 현재 상태의 부분 문제 최적 해 구한뒤 부분해 집합에 추가

2. 실행 가능성 검사 : 새로운 부분 해 집합이 조건에 알맞는지 확인

3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지 확인

<br/>

## 거스름돈 줄이기

- 손님이 지불한 금액에서 물건값을 빼고 거스름돈을 지불하는데,

  거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄이는 문제

### 탐욕 기법 적용

1. 해 선택
   - 가장 좋은 해 = 단위가 가장 큰 동전을 골라 거스름돈에 추가.

2. 실행 가능성 검사
   - 거스름돈이 손님에게 줘야할 금액을 초과하는지 확인. 초과하면 마지막 동전을 빼고 다시 1번
3. 해 검사
   - 거스름돈이 손님에게 줘야할 금액과 일치하는 지 확인. 모자라면 다시 1번

- 최적해를 반드시 구한다는 보장이 없음

  - ex) 거스름돈 종류가 500, 400, 100, 50, 10 처럼 배수 관계가 아닌 경우

  - 거스름돈 800원 -> 탐욕: 500원 1개, 100원 3개

    하지만 최적은 400원 2개.

<br/>

## 배낭 문제

### 문제 설명

- 도둑이 창고에 잠입해 배낭에 훔친 물건을 담고자 한다.
- 배낭은 담을 수 있는 물건의 총 무게(W)가 정해져 있음.
- 창고에는 n개의 물건이 있고 각각의 물건에는 무게와 값이 정해져 있다.
- 배낭이 수용할 수 있는 무게를 초과하지 않으면서, 값이 최대가 되는 물건들을 담아야하는 문제.

- S = {item1, item2, ...} 물건들의 집합
- wi = itemi의 무게, Pi = itemi의 값
- W : 배낭이 수용가능한 총 무게
- 문제 정의
  - sum{i in A}(wi) <= W를 만족하면서 sum{i in A}(Pi)가 최대가 되도록하는 A를 결정하는 문제
- 0-1Knapsack 문제
  - 물건을 쪼갤 수 없는 경우
- Fractional Knapsack
  - 물건을 쪼갤 수 있는 경우

### 0-1 Knapsack 문제 접근

- 완전 검색 방법
  - 완전 검색으로 물건들의 집합 S에 대한 모든 부분 집합 구하기
  - 부분집합의 총무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 값 찾기

- 탐욕적 방법 1

  - 값이 비싼 물건부터 채운다.

  - ex) W= 30kg, 

    물건 1 = (25kg, 10만원), 물건2 = (10kg, 9만원) , 물건3 = (10kg, 5만원)

  - 최적해 아닐 수 있음.

- 탐욕적 방법 2
  - 가벼운 물건부터 채운다.
  - 역시 최적해 아닐 수 있음.
- 탐욕적 방법 3
  - 무게 대비 가격이 비싼 물건부터 채운다.
  - 역시 최적해 아닐 수 있음.
- 탐욕적인 방법으로는 구하기 힘듦.

### Fractional Knapsack 문제 접근

- 탐욕적 방법
  - 무게 대비 가격이 비싼 물건부터 채운다.
  - 탐욕 = 최적해 보장



<br/>

## 회의실 배정하기

- 회의실 하나에 다수의 회의가 신청된 상태
- 각 회의에는 시작시간과 종료시간이 있으며 회의 시간이 겹치면 회의들이 동시에 열릴 수 없다.
- 가능한 많은 회의가 열리기 위해서는 회의들을 어떻게 배정해야할까
- 또는 최대 몇개의 회의가 열릴 수 있을까

- 

### 활동 선택 문제

- 시작시간과 종료시간이 있는 n개의 활동들의 집합 A, 1 <= i <= n에서 서로 겹치지 않는 최대 갯수의 활동들의 집합 S를 구하는 문제

- 양립 가능한 활동들의 크기가 최대가 되는 S{0,n+1}의 부분집합을 선택하는 문제

- 접근

  - 종료시간 순으로 활동들을 정렬
  - S{0, n+1}은 a0의 종료 시간부터 an+1의 시작시간 사이에 포함된 활동들

- 탐욕 기법 적용

  - 공집합이 아닌 하위 문제 S{i,j}가 있고 S{i,j}에 속한 활동 am은 종료 시간이 가장 빠른 활동

  1. 하위 문제 S{i,j}에서 종료 시간이 가장 빠른 활동을 선택

  2. S{i, m}은 공집합. am을 선택하면 공집합이 아닌 하위 문제 S{m, j}가 남음

  3. 1, 2 반복.

- 탐욕 기법을 적용한 반복 알고리즘

  ```python
  # A : 활동들의 집합, S; 선택된 활동들 집합
  # si: 시작시간, fi: 종료 시간, 1 <= i <= n
  
  A.sort()
  S = [A[0]]
  j = 0
  for i in range(1, n+1):
      if s[i] >= f[j]:
          S.append(A[i])
          j = i
  ```

- 재귀 알고리즘

  ```python
  # A : 활동들의 집합, S; 선택된 활동들 집합
  # si: 시작시간, fi: 종료 시간, 1 <= i <= n
  
  def recursive_selection(i, j):
      m = i+1
      
      while m < j and s[m] < f[i]:  # 종료 시간이 가장 빠른 활동 선택
          m += 1
      if m < j : return [a[m]] + recursive_selection(m, j)
      else: return []
  ```

<br/>

## 탐욕 알고리즘의 필수 요소

- 탐욕적 선택 속성
  - 탐욕적 선택이 최적해로 갈 수 있음을 보여야함
  - => 탐욕적 선택이 항상 안전함
- 최적 부분 구조
  - 최적화 문제를 정형화해야함
  - => 하나의 선택을 하면 풀어야할 하나의 하위 문제가 남음
- **원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해** 임을 증명해야함



### 탐욕 기법과 동적 계획법의 비교

- 탐욕 기법
  - 지역 최적 선택
  - 하위 문제 풀기보다 탐욕적 선택이 먼저 이뤄짐
  - Top-down 방식
  - 일반적으로 빠르고 간결
- 동적 계획법
  - 하위 문제 해를 기반으로 선택
  - 하위 문제가 먼저 해결됨
  - Bottom-Up 방식
  - 좀더 느리고 복잡



### 대표적인 탐욕 기법 알고리즘들

- Prim
- Kruskal
- Dijsktra
- Huffman tree & code

