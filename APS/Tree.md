# 트리 Tree

## 트리의 개념

- 비선형 구조
- 원소들간 1:  n 관계
- 계층형 자료구조
- 상위에서 하위로 갈수록 확장되는 트리 모양 구조



<br/>

## 트리의 정의

- 사이클이 없는 무향 연결 그래프

- 한 개 이상의 노드로 이뤄진 유한 집합
- 노드 중 최상위 노드를 루트
- 나머지 노드들은 n개의 분리 집합 T1, ... Tn으로 분리가능
- 이들 T1, ... , Tn은 각각 트리가 되며 서브트리라고 한다.

### 용어

- 노드 : 트리의 원소
- 간선 : 노드를 연결하는 선
- 루트 노드 : 트리 시작 노드

- 높이 : 루트 노드에서 노드 까지 이르는 간선의 수
- 차수 : 노드에 연결된 자식 노드의 수

<br/>

## 이진트리

- 모든 노드들이 2개의 서브 트리를 갖는 특별한 트리
- 각 노드가 자식 노드를 최대 2개까지만 가질 수 있는 트리
  - 왼쪽 자식노드
  - 오른쪽 자식노드
- 레벨 i까지의 노드 최대 개수는 2^i
- 높이가 h인 이진트리가 가질 수 있는 노드의 개수는 h+1 ~ 2^(h+1) - 1



### 포화 이진 트리

- 모든 레벨에 노드가 포화 상태인 이진트리
- 높이가 h일 때 2^(h+1) - 1노드를 가진 이진 트리
- 1번부터 2^(h+1)-1 번 까지 노드 번호를 가짐



### 완전 이진 트리

- 높이가 h이고 노드 수가 n개 일 때, 1번부터 n번까지 빈 자리가 없는 이진 트리



### 편향 이진 트리

- 한쪽 방향의 자식 노드만을 가진 이진 트리

<br/>

## 이진트리의 순회

- 순회 : 트리의 각 노드를 중복되지 않게 전부 방문하는 것

- 3가지 순회 방법

  - 전위 순회
  - 중위 순회

  - 후위 순회

### 전위 순회

- 부모 노드 방문 후, 자식 노드 좌, 우 방문

  1. 현재 노드 n 방문
  2. 현재 노드 n의 왼쪽 서브 트리로 이동
  3. 현재 노드 n의 오른쪽 서브 트리로 이동

- ```python
  def preodrer_traverse(T):
      if T:
          visited(T)
          preoder_traverse(T.left)
          preorder_traverse(T.right)
  ```

  

### 중위 순회

- 왼쪽 자식, 부모 노드, 오른쪽 자식 순으로 방문

  1. 현재 노드 n의 왼쪽 서브 트리로 이동
  2. 현재 노드 n 방문
  3. 현재 노드 n의 오른쪽 서브 트리로 이동

- ```python
  def inorder_traverse(T):
      if T:
          inorder_traverse(T.left)
          visit(T)
          inorder_traverse(T.right)
  ```

  

### 후위 순회

- 자식 노드 좌우 순 방문 후 부모노드 방문
  1. 현재 노드 n의 왼쪽 서브 트리로 이동
  2. 현재 노드 n의 오른쪽 서브 트리로 이동
  3. 현재 노드 n 방문

- ```python
  def postorder_traverse(T):
      if T:
          postorder_traverse(T.left)
          postorder_traverse(T.right)
          visit(T)
  ```



### 순회 +

- 후위 순회의 경우, 언제나 루트 노드를 마지막에 방문한다.

- 중위 순회의 경우, 루트 노드를 기준으로 루트 노드보다 먼저 방문한게 왼쪽 서브트리, 나중에 방문한게 오른쪽 서브트리다.

- 전위 순회의 경우, 언제나 루트 노드를 가장 먼저 방문한다.

  



<br/>

## 이진트리의 표현

### 배열로 표현

- 루트에게 번호 1 부여
- 레벨 n에 있는 노드에 대해 왼쪽부터 차례대호 2^n 부터 2^(n+1) -1 까지 번호 부여 ( 레벨 0부터 시작 )

- 이러면 노드 번호가 i인 노드의
  - 부모 노드 번호  : i//2
  - 왼쪽 자식 노드 번호 : 2 * i
  - 오른쪽 자식 노드 번호 : 2 * i + 1
- 레벨 n의 노드 시작 번호 : 2 ^ n
- 높이가 h인 이진 트리를 위한 배열의 크기
  - 레벨 i의 최대 노드 수가 2^i 이므로 2^(h+1) -1

- 단점
  - 편향 이진 트리의 경우 메모리 낭비
  - 트리 중간에 새로운 노드 삽입이나 기존 노드 삭제 등 변경이 어려움

### 연결리스트로 표현

- 이진 트리 모든 노드는 최대 2개의 자식 노드를 가지므로
- [left, 데이터, right] 모양의 단순 연결 리스트 노드를 사용해 구현



<br/>

## 수식 트리

- 수식을 표현하는 이진 트리
- 수식 이진 트리 라고도 함
- 연산자는 루트 노드나 가지 노드
- 피연산자는 잎 노드

### 수식 트리 순회

- 중위 순회 시 중위 표기법
- 후위 순회 시 후위 표기법
- 전위 순회 시 전위 표기법

<br/>

## 이진 탐색 트리

- 탐색을 효율적으로 하기 위한 자료 구조
- 모든 원소는 서로 다른 키를 갖는다.
- key(left) < key(root) < key(right) 로 구성되어 **중위 순회 시 오름 차순**으로 정렬됨
- 모든 서브트리가 이진 탐색 트리다.



### 탐색연산

- 루트에서 시작
- 탐색할 키 값 x를 루트 노드의 키값과 비교
  - 같으면 끝
  - x < 루트 노드 키값 : 왼쪽 서브트리에 대해 탐색연산
  - x > 루트 노드 키값 : 오른쪽 서브트리에 대해 탐색 연산

- 순환적으로 탐색 연산 반복



### 삽입 연산

- 새로운 원소를 트리에 삽입하는 연산
- 과정
  - 탐색 연산 수행
    - 같은 원소가 있으면 삽입할 수 없음
    - 탐색 실패가 결정되는 위치가 삽입 위치
  - 탐색 실패 위치에 원소 삽입
  - (있어야할 자리에 없으면 거기에 삽입한다)



### 성능

- 탐색, 삽입, 삭제 시간은 트리의 높이 만큼 시간이 걸림
- 평균(이진 트리가 균형적으로 생성되는 경우)
  - O(log n)
- 최악의 경우
  - 한쪽으로 치우친 이진 트리의 경우
  - O(n)
  - 순차 탐색과 시간복잡도과 같음



 