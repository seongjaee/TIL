# DFS(깊이 우선 탐색)

- 비선형 구조인 그래프는 그래프의 모든 자료를 빠짐없이 검색하는 게 중요
- 모든 자료를 검색하는 두 가지 방법
  - 깊이 우선 탐색(Depth First Search, DFS)
  - 너비 우선 탐색(Breadth First Search, BFS)
- 깊이 우선 탐색은
  - 시작 정점에서 한 방향으로 갈 수 있는 곳까지 깊이 들어가며 탐색.
  - 더 들어갈 수 없으면 가장 마지막에 만난 갈림길이 있는 정점으로 돌아감.
  - 다른 방향으로 탐색 반복
- "가장 마지막에 만난 갈림길로 돌아간다" -> 후입선출? -> 스택으로 구현 가능

- 스택을 사용한 DFS 과정

1. 시작 정점 v 방문
2. 정점 v에 인접한 정점 중에서
   - 방문하지 않은 정점 w 가 있으면 정점 v를 스택에 push, 정점 w 방문, w를 현재의 v로 함
   - 방문하지 않은 정점이 없으면 스택에서 pop해서 가장 마지막 방문 정점을 현재의 v로 함
3. 스택이 빌 때까지 2.를 반복



## 그래프 표현 방법

예시

![graph](DFS.assets/graph.png)

### 인접 행렬

정점 i 와 정점 j가 연결되어있으면 `adj[i][j] = 1` 아니면 `adj[i][j] = 0`으로 표현

```
adj = [[0, 0, 0, 0, 0, 0, 0, 0],
 	   [0, 0, 1, 1, 0, 0, 0, 0],
 	   [0, 1, 0, 0, 1, 1, 0, 0],
 	   [0, 1, 0, 0, 0, 1, 0, 0],
 	   [0, 0, 1, 0, 0, 0, 1, 0],
 	   [0, 0, 1, 1, 0, 0, 1, 0],
 	   [0, 0, 0, 0, 1, 1, 0, 1],
 	   [0, 0, 0, 0, 0, 0, 1, 0]]
```

### 

## DFS 코드

```python
def dfs(s, V):
    # s : 시작점
    # V : 정점 개수
    
    # 방문 배열 visited & 스택 초기화
    visited = [0] * n
	stack = []
   	visited[s] = 1
    i = s  # 현재 방문한 정점 i
    print(i)
    while i != 0:
        for w in range(1, V+1):
            # 연결된 정점 중 방문하지 않은 곳 발견
            if adj[i][w] and visited[w] == 0:
                stack.append(i)  # 방문 경로 저장
                i = w            # 새 방문지 이동
                visited[w] = 1
                print(i)
                break
        # 방문하지 않은 곳이 없으면
        else:
            if stack:
                i = stack.pop()
            else:
                i = 0
   

adj = [[0, 0, 0, 0, 0, 0, 0, 0],
 	   [0, 0, 1, 1, 0, 0, 0, 0],
 	   [0, 1, 0, 0, 1, 1, 0, 0],
 	   [0, 1, 0, 0, 0, 1, 0, 0],
 	   [0, 0, 1, 0, 0, 0, 1, 0],
 	   [0, 0, 1, 1, 0, 0, 1, 0],
 	   [0, 0, 0, 0, 1, 1, 0, 1],
 	   [0, 0, 0, 0, 0, 0, 1, 0]]

dfs(1, 7)
```

