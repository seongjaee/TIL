# 삽입 정렬 (Insertion sort)

- 배열의 요소들에 대해, 이미 정렬된 배열 부분과 앞에서부터 차례대로 비교하면서 요소 자신의 위치를 찾아 삽입하는 정렬



<br/>



## 정렬 과정

- 앞에서부터 정렬되어있는 배열을 만들어 나감.

- `0`번째 인덱스부터 ~ `j-1`번째 인덱스 까지 정렬되어 있을 때,

  뒤에서부터(`j-1`번째 값부터)  `j`번째  값과 비교하여 `j`번째 값의 위치를 찾아 삽입함.



<br/>



## 예시 과정

- 0 ~ 1번째 인덱스까지 정렬

  ```python
  [13, <9>, 3, 6, 1]
        ^
  ```

  1번째 인덱스 값인 9는 맨 앞자리로

  ```python
  [<9>, 13, 3, 6, 1]
  ```

- 0 ~ 2번째 인덱스까지 정렬

  ```python
  [9, 13, <3>, 6, 1]
           ^
  ```

  2번째 인덱스 값인 3은 맨 앞자리로

  ```python
  [<3>, 9, 13, 6, 1]
  ```

- 0 ~ 3번째 인덱스까지 정렬

  ```python
  [3, 9, 13, <6>, 1]
              ^
  ```

  3번째 인덱스 값이 6은 3과 9사이로

  ```python
  [3, <6>, 9, 13, 1]
  ```

- 0 ~ 4번째 인덱스까지 정렬

  ```python
  [3, 9, 13, 6, <1>]
                 ^
  ```

  4번째 인덱스 값인 1은 맨 앞자리로

  ```python
  [<1>, 3, 6, 9, 13]
  ```

  

<br/>



## 코드

```python
def insert_sort(arr):
    # 앞에서부터 차례로 정렬
    for i in range(1, len(arr)):
        j = i
        # 큰 값이 앞에 있으면 서로 위치를 바꿈
        while arr[j] < arr[j-1] and j > 0:
            arr[j-1], arr[j] = arr[j], arr[j-1]
            j -= 1
        
    return arr
```

 

<br/>



## 정리

- 구현이 간단하다는 장점
- 선택 정렬이나 버블 정렬보다는 빠르다. n이 작을 때 효과적
- 비교와 교환 방식
- 같은 값의 원래 순서가 바뀌지 않는 안정 정렬
- 이미 어느 정도 정렬된 경우 효율적.
- 평균 시간 복잡도 : O(N^2)
- 최악 시간 복잡도 : O(N^2)